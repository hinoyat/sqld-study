# 1-5. 식별자 (Identifier)

## 식별자의 개념
- 하나의 엔터티에 존재하는 여러 속성 중, **엔터티를 대표할 수 있는 속성**
- 반드시 하나의 유일한 식별자가 존재해야 함
- 논리 모델링 단계에서는 **식별자(Identifier)** 라고 하고, 물리 모델링 단계에서는 **키(Key)** 라고 표현

### 예시
- 학생 엔터티의 주식별자 → 학생번호 속성
- 학생 테이블의 기본키(PK) → 학생번호 컬럼

---

## 주식별자의 특징

1. **유일성 (Uniqueness)**
    - 모든 인스턴스를 고유하게 구분 가능해야 함
    - 예) 이름은 동명이인이 존재할 수 있으므로 부적합, 학번·사번은 적합

2. **최소성 (Minimality)**
    - 유일성을 만족하는 최소한의 속성만으로 구성
    - 예) 학생번호만으로 충분한데, 학생번호+이름으로 구성하는 것은 불필요

3. **불변성 (Stability)**
    - 한 번 지정된 주식별자의 값은 변하지 않아야 함
    - 예) 학생번호는 변경 불가, 이름·주소는 변동 가능하므로 부적합

4. **존재성 (Existence)**
    - 모든 인스턴스에서 반드시 값이 존재해야 하며, NULL 허용 불가

---

## 식별자의 분류

### 1) 대표성 여부에 따른 분류
- **주식별자 (Primary Identifier)**
    - 유일성과 최소성을 만족
    - 엔터티를 대표하며, 다른 엔터티와 참조 관계 연결 가능
- **보조식별자 (Alternate Identifier)**
    - 엔터티 내 인스턴스를 구분할 수는 있으나 대표성 부족
    - 참조관계 연결은 불가
    - 예) 주민등록번호 대신 학생번호를 주식별자로, 주민등록번호는 보조식별자

---

### 2) 생성 여부에 따른 분류
- **내부 식별자 (Internal Identifier)**
    - 다른 엔터티 참조 없이 자체적으로 생성되는 식별자
    - 예) 고객번호, 상품번호
- **외부 식별자 (External Identifier)**
    - 다른 엔터티와의 관계로부터 생성된 식별자 (외래키)
    - 예) 주문 엔터티의 고객번호(FK)

---

### 3) 속성 수에 따른 분류
- **단일 식별자 (Single Identifier)**
    - 하나의 속성으로 구성
    - 예) 학번, 사번
- **복합 식별자 (Composite Identifier)**
    - 두 개 이상의 속성으로 구성
    - 예) (학생번호 + 과목코드) → 수강기록의 기본키

---

### 4) 대체 여부에 따른 분류
- **본질 식별자 (Natural Identifier)**
    - 업무적으로 원래 존재하는 속성을 식별자로 사용
    - 예) 주민번호, 사업자등록번호
- **인조 식별자 (Surrogate Identifier)**
    - 인위적으로 생성한 속성 (일련번호 등)
    - 자동 증가 값(Auto Increment)을 활용해 설계 단순화  

---

## 주식별자 도출 기준

1. **업무에서 자주 이용되는 속성을 우선**
    - 같은 조건을 만족한다면 업무적으로 더 많이 사용되는 속성을 주식별자로 선택
    - 예) 학생번호 vs 주민번호 → 주민번호도 유일하지만, 실제 업무에서는 학생번호 사용

2. **명칭이나 내역 등은 피한다**
    - 이름, 부서명과 같은 속성은 변동 가능성이 크므로 주식별자로 부적절
    - 예) 부서명 대신 부서코드를 인위적으로 생성해 사용

3. **속성 수는 최소화한다**
    - 주식별자를 너무 많은 속성으로 구성하면 조인 시 성능 저하
    - 일반적으로 7~8개 이상이면 인조 식별자를 새로 생성하는 것이 바람직
    - 예) 주문일자 + 주문상품코드 + 고객번호 … 대신 주문번호 속성 추가

---

## 관계 간 엔터티 구분

- **강한 개체 (Strong Entity)**
    - 독립적으로 존재 가능한 엔터티
    - 예) 고객, 부서

- **약한 개체 (Weak Entity)**
    - 독립적으로 존재할 수 없고, 다른 엔터티에 종속
    - 부모 엔터티의 식별자를 포함해야 존재 가능
    - 예) 계좌(고객에 종속), 주문상세(주문에 종속)

---

## 식별 관계와 비식별 관계

1. **식별 관계 (Identification Relationship)**
    - 부모 엔터티의 기본키가 자식 엔터티의 **기본키 일부로 포함**되는 관계
    - ERD에서 **실선**으로 표시
    - 예)
        - 사원(#사원번호)
        - 교육이력(#사원번호(FK), #수강일자)

2. **비식별 관계 (Non-identification Relationship)**
    - 부모 엔터티의 기본키를 자식 엔터티에서 **일반 속성(FK)** 으로만 사용하는 관계
    - 자식 엔터티의 기본키에는 포함되지 않음
    - ERD에서 **점선**으로 표시
    - 예) 부서(#부서번호) ↔ 사원(부서번호(FK), 사원번호(PK))  

---

## Key의 종류

1. **기본키 (Primary Key, PK)**
    - 엔터티(테이블)를 대표하는 키
    - 각 인스턴스를 유일하게 식별 가능해야 함
    - NULL 불가, 중복 불가
    - 예) 학생(학번), 주문(주문번호)

2. **후보키 (Candidate Key)**
    - 유일성과 최소성을 모두 만족하는 속성 집합
    - 여러 개 존재할 수 있으며, 이 중 하나가 기본키로 선택됨
    - 선택되지 않은 후보키들은 **대체키**가 됨
    - 예) 학생 테이블에서 `학번`, `주민번호` 모두 후보키

3. **슈퍼키 (Super Key)**
    - 유일성은 만족하지만 최소성은 만족하지 못하는 키
    - 필요 이상의 속성을 포함하는 경우
    - 예) (학번 + 이름) → 학번만으로 충분한데 이름까지 포함

4. **대체키 (Alternate Key)**
    - 후보키 중에서 기본키로 채택되지 않은 키
    - 여전히 각 인스턴스를 구분 가능하지만, 대표성 없음
    - 예) 주민번호 (학생 테이블에서 학번이 기본키일 경우)

5. **외래키 (Foreign Key, FK)**
    - 다른 테이블의 기본키를 참조하는 속성
    - 참조 무결성을 유지해야 함 (부모 테이블에 없는 값은 불가)
    - 부모 엔터티와 자식 엔터티 간의 관계를 표현
    - 예) 주문 테이블의 `고객번호(FK)` → 고객 테이블의 `고객번호(PK)`  
